package com.rizsti.fragments;

import android.app.Fragment;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;

import com.parse.GetCallback;
import com.parse.Parse;
import com.parse.ParseException;
import com.parse.ParseObject;
import com.parse.ParseQuery;
import com.rizsti.classes.Character;
import com.rizsti.teddy.R;

/**
 * 
 * @author Andrea Dewey
 *
 */
public class Basic extends Fragment {
	
	private View v;
	private Character c;
	
	//Numbers for calculations
	private final int SUBMOD = 10;
	private final int HALF = 2;
	
	//Arrays
	private final String RACES[] = {"Race", "Human", "Elf", "Dwarf", "Half-Elf", "Driders", "Half-Orc", "Halfling", "Goblin", "Kobold", "Orc"};
	private final String CLASSES[] = {"Class", "Barbarian", "Bard", "Cleric", "Druid", "Fighter", "Monk", "Paladin", "Ranger", "Rogue", "Sorcerer", "Wizard"};
	private final String ALIGNMENT[] = {"Alignment", "Lawful Good", "Neutral Good", "Chaotic Good", "Lawful Neutral", "Neutral", "Chaotic Neutral", "Lawful Evil", "Neutral Evil", "Chaotic Evil"};
	private final String DEITIES[] = {"Deity", "Heironeous", "Moradin", "Yondalla", "Ehlonna", "Garl Glittergold", "Pelor", "Corellon Larethian", "Kord", "Wee Jas", "St. Cuthbert", "Boccob", "Fharlanghn", "Obad-Hai", "Olidammara", "Hextor", "Necrull", "Vecna", "Erythnul", "Gruumsh"};

	//Default display values
	private final String dv = "0";
	
	//page elements
	public Spinner classs, align, deity, race;
	EditText name, level, strScore, strTmpScore, conScore, conTmpScore, dexScore, dexTmpScore,
		intScore, intTmpScore, chaScore, chaTmpScore, wisScore, wisTmpScore;
	TextView strMod, strTmpMod, conMod, conTmpMod, dexMod, dexTmpMod, intMod, intTmpMod,
		chaMod, chaTmpMod, wisMod, wisTmpMod;
		
	
	@Override
	  public View onCreateView(LayoutInflater inflater, ViewGroup container,
	      Bundle savedInstanceState) {
	   v= inflater.inflate(R.layout.fragment_basic,
	        container, false);
	   
	   	//get the elements in the beginning half of the layout
	   	//Edit Texts
	    //Initialize parse
	 	Parse.initialize(getActivity(), "3sfbEGVbyq3lgjRZJJbLgonYfHz83LkaJlp7e0WP", "HFMtnDO5kzeSqcL9TEXrtRsrvWCwNsZUBGvsndbS"); 
	 		
	   	name 	= (EditText) v.findViewById(R.id.etName);
		level	= (EditText) v.findViewById(R.id.etLevel);
		//Spinners		
		classs	= (Spinner) v.findViewById(R.id.spClass);
		align 	= (Spinner) v.findViewById(R.id.spAlign);
		deity 	= (Spinner) v.findViewById(R.id.spDeity);
		race 	= (Spinner) v.findViewById(R.id.spRace);
		
		//Elements from the end half of the layout
		//Edit Texts  --  Stat scores
		strScore 	= (EditText) v.findViewById(R.id.strScore);
		strTmpScore = (EditText) v.findViewById(R.id.strTmpScore);
		dexScore	= (EditText) v.findViewById(R.id.dexScore);
		dexTmpScore = (EditText) v.findViewById(R.id.dexTmpScore);
		conScore 	= (EditText) v.findViewById(R.id.conScore);
		conTmpScore	= (EditText) v.findViewById(R.id.conTmpScore);
		intScore	= (EditText) v.findViewById(R.id.intScore);
		intTmpScore = (EditText) v.findViewById(R.id.intTmpScore);
		wisScore	= (EditText) v.findViewById(R.id.wisScore);
		wisTmpScore = (EditText) v.findViewById(R.id.wisTmpScore);
		chaScore	= (EditText) v.findViewById(R.id.chaScore);
		chaTmpScore	= (EditText) v.findViewById(R.id.chaTmpScore);		
		
		//TextViews  --  Stat modifiers
		strMod		= (TextView) v.findViewById(R.id.strMod);
		strTmpMod	= (TextView) v.findViewById(R.id.strTmpMod);
		dexMod		= (TextView) v.findViewById(R.id.dexMod);
		dexTmpMod	= (TextView) v.findViewById(R.id.dexTmpMod);
		conMod		= (TextView) v.findViewById(R.id.conMod);
		conTmpMod	= (TextView) v.findViewById(R.id.conTmpMod);
		intMod		= (TextView) v.findViewById(R.id.intMod);
		intTmpMod	= (TextView) v.findViewById(R.id.intTmpMod);
		wisMod		= (TextView) v.findViewById(R.id.wisMod);
		wisTmpMod	= (TextView) v.findViewById(R.id.wisTmpMod);
		chaMod		= (TextView) v.findViewById(R.id.chaMod);
		chaTmpMod	= (TextView) v.findViewById(R.id.chaTmpMod);
		
		//Set the default of the editTexts to 0 to ensure that onResume does not provide errors
		strScore.setText(dv);
		strTmpScore.setText(dv);
		dexScore.setText(dv);
		dexTmpScore.setText(dv);
		conScore.setText(dv);
		conTmpScore.setText(dv);
		intScore.setText(dv);
		intTmpScore.setText(dv);
		wisScore.setText(dv);
		wisTmpScore.setText(dv);
		chaScore.setText(dv);
		chaTmpScore.setText(dv);
		
		//Set the onEditorActionListeners for the EditTexts
		strScore.setOnFocusChangeListener(new StatsListener());
		strTmpScore.setOnFocusChangeListener(new StatsListener());
		dexScore.setOnFocusChangeListener(new StatsListener());
		dexTmpScore.setOnFocusChangeListener(new StatsListener());
		conScore.setOnFocusChangeListener(new StatsListener());
		conTmpScore.setOnFocusChangeListener(new StatsListener());
		intScore.setOnFocusChangeListener(new StatsListener());
		intTmpScore.setOnFocusChangeListener(new StatsListener());
		wisScore.setOnFocusChangeListener(new StatsListener());
		wisTmpScore.setOnFocusChangeListener(new StatsListener());
		chaScore.setOnFocusChangeListener(new StatsListener());
		chaTmpScore.setOnFocusChangeListener(new StatsListener());
		
		level.setOnFocusChangeListener(new LevelListener());
		
		//Create that adapters to populate the spinners
		ArrayAdapter<String> adRace = new ArrayAdapter<String>(getActivity(), R.layout.spinner_center, RACES);
		ArrayAdapter<String> adClass = new ArrayAdapter<String>(getActivity(), R.layout.spinner_center, CLASSES);
		ArrayAdapter<String> adAlign = new ArrayAdapter<String>(getActivity(), R.layout.spinner_center, ALIGNMENT);
		ArrayAdapter<String> adDeities = new ArrayAdapter<String>(getActivity(), R.layout.spinner_center, DEITIES);
		
		//Set the onItemSelectedListener to populate character data when a class is selected
		classs.setOnItemSelectedListener(new SelectedListener());
		
		
		//Set the spinners' adapters
		classs.setAdapter(adClass);
		align.setAdapter(adAlign);
		deity.setAdapter(adDeities);
		race.setAdapter(adRace);
		
		
		ParseObject spell = new ParseObject("Spells");
		//hasnt' been inserted yet
		spell.put("Name", "Astral Projection");
		spell.put("School", "Necromancy");
		spell.put("Level","Clr 9, Sor/Wiz 9, Travel 9");
		spell.put("Components", "V,S,M");
		spell.put("CastingTime", "30 minutes");
		spell.put("Range", "Touch");
		spell.put("Target", "You plus one additional willing creature touched per two caster levels");
		spell.put("Duration", "See text");
		spell.put("SavingThrow", "None");
		spell.put("SpellResistance", "Yes");
		spell.put("Description", "By freeing your spirit from your physical body, this spell allows you to " +
				"project an astral body onto another plane altogether. You can bring the astral forms of " +
				"other willing creatures with you, provided that these subjects are linked in a circle with " +
				"you at the time of the casting. These fellow travelers are dependent upon you and must " +
				"accompany you at all times. If something happens to you during the journey, your companions " +
				"are stranded wherever you left them. You project your astral self onto the Astral Plane, " +
				"leaving your physical body behind on the Material Plane in a state of suspended animation. " +
				"The spell projects an astral copy of you and all you wear or carry onto the Astral Plane." +
				" Since the Astral Plane touches upon other planes, you can travel astrally to any of these " +
				"other planes as you will. To enter one, you leave the Astral Plane, forming a new physical" +
				" body (and equipment) on the plane of existence you have chosen to enter. While you are on " +
				"the Astral Plane, your astral body is connected at all times to your physical body by a" +
				" silvery cord. If the cord is broken, you are killed, astrally and phys- ically. Luckily," +
				" very few things can destroy a silver cord (see the Dungeon Master’s Guide for more " +
				"information). When a second body is formed on a different plane, the incorporeal silvery " +
				"cord remains invisibly attached to the new body. If the second body or the astral form is " +
				"slain, the cord simply returns to your body where it rests on the Material Plane, thereby " +
				"reviving it from its state of suspended animation. Although astral projections are able to " +
				"function on the Astral Plane, their actions affect only creatures existing on the Astral " +
				"Plane; a physical body must be material- ized on other planes. You and your companions may " +
				"travel through the Astral Plane indefinitely. Your bodies simply wait behind in a state of " +
				"suspended animation until you choose to return your spirits to them. The spell lasts until " +
				"you desire to end it, or until it is terminated by some outside means, such as dispel magic" +
				" cast upon either the physical body or the astral form, the breaking of the silver cord, or" +
				" the destruction of your body back on the Material Plane (which kills you). Material" +
				" Component: A jacinth worth at least 1,000 gp, plus a silver bar worth 5 gp for each person " +
				"to be affected. ");
		spell.saveInBackground();
		
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Atonement");
		spell.put("School", "Abjuration");
		spell.put("Level","Clr 5, Drd 5");
		spell.put("Components", "V,S,M,F,DF,XP");
		spell.put("CastingTime", "1 hour");
		spell.put("Range", "Touch");
		spell.put("Target", "Living creature touched");
		spell.put("Duration", "Instantaneous");
		spell.put("SavingThrow", "None");
		spell.put("SpellResistance", "Yes");
		spell.put("Description", "This spell removes the burden of evil acts or misdeeds from the subject." +
				" The creature seeking atonement must be truly repentant and desirous of setting right its" +
				" misdeeds. If the atoning creature committed the evil act unwittingly or under some form" +
				" of compulsion, atonement operates normally at no cost to you. However, in the case of a " +
				"creature atoning for deliberate misdeeds and acts of a knowing and willful nature, you must" +
				" intercede with your deity (requiring you to expend 500 XP) in order to expunge the" +
				" subject’s burden. Many casters first assign a subject of this sort a quest " +
				"(see geas/quest) or similar penance to determine whether the creature is truly contrite " +
				"before casting the atonement spell on its behalf. Atonement may be cast for one of several" +
				" purposes, depending on the version selected. Reverse Magical Alignment Change: If a" +
				" creature has had its alignment magically changed, atonement returns its alignment to its " +
				"original status at no cost in experi- ence points. Restore Class: A paladin who has lost her " +
				"class features due to committing an evil act may have her paladinhood restored to her by this" +
				" spell. Restore Cleric or Druid Spell Powers: A cleric or druid who has lost the ability to " +
				"cast spells by incurring the anger of his or her deity may regain that ability by seeking " +
				"atonement from another cleric of the same deity or another druid. If the trans- gression was" +
				" intentional, the casting cleric loses 500 XP for his intercession. If the transgression was " +
				"unintentional, he does not lose XP. Redemption or Temptation: You may cast this spell upon a " +
				"creature of an opposing alignment in order to offer it a chance to change its alignment to " +
				"match yours. The prospective subject must be present for the entire casting process. Upon " +
				"completion of the spell, the subject freely chooses whether it retains its original alignment " +
				"or acquiesces to your offer and changes to your alignment. No duress, compulsion, or magical" +
				" influence can force the subject to take advantage of the opportunity offered if it is" +
				" unwilling to abandon its old alignment. This use of the spell does not work on outsiders or" +
				" any creature incapable of changing its alignment naturally. Though the spell description " +
				"refers to evil acts, atonement can also be used on any creature that has performed acts " +
				"against its alignment, whether those acts are evil, good, chaotic, or lawful. Note:" +
				" Normally, changing alignment is up to the player (for PCs) or the DM (for NPCs). This use" +
				" of atonement simply offers a believable way for a character to change his or her alignment " +
				"drastically, suddenly, and definitively. Material Component: Burning incense. Focus: In " +
				"addition to your holy symbol or normal divine focus, you need a set of prayer beads (or " +
				"other prayer device, such as a prayer wheel or prayer book) worth at least 500 gp. XP Cost:" +
				" When cast for the benefit of a creature whose guilt was the result of deliberate acts, the" +
				" cost to you is 500 XP per casting (see above).");
		spell.saveInBackground();
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Augury");
		spell.put("School", "Divination");
		spell.put("Level","Clr 2");
		spell.put("Components", "V,S,M,F");
		spell.put("CastingTime", "1 minute");
		spell.put("Range", "Personal");
		spell.put("Target", "You");
		spell.put("Duration", "Instantaneous");
		spell.put("SavingThrow", "None");
		spell.put("SpellResistance", "");
		spell.put("Description", "An augury can tell you whether a particular action will bring good or " +
				"bad results for you in the immediate future. For example, if a character is considering " +
				"destroying a weird seal that closes a portal, an augury might determine whether that act " +
				"is a good idea. The base chance for receiving a mean- ingful reply is 70% + 1% per caster " +
				"level, to a maximum of 90%; the DM makes the roll secretly. The DM may determine that a " +
				"question is so straightforward that a suc- cessful result is automatic, or so vague as to" +
				" have no chance of success. If the augury succeeds, you get one of four results: " +
				" -Weal (if the action will probably bring good results)." +
				" -Woe (for bad results). " +
				" -Weal and woe (for both). " +
				" -Nothing (for actions that don’t have especially good or bad results)." +
				"If the spell fails, you get the “nothing” result. A cleric who gets the “nothing” result" +
				" has no way to tell whether it was the consequence of a failed or successful augury. The " +
				"augury can see into the future only about half an hour, so anything that might happen after" +
				" that does not affect the result. Thus, the result might not take into account the long-term " +
				"consequences of a contemplated action. All auguries cast by the same person about the same " +
				"topic use the same dice result as the first casting. Material Component: Incense worth at " +
				"least 25 gp. Focus: A set of marked sticks, bones, or similar tokens of at least 25 gp " +
				"value.");
		spell.saveInBackground();
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Awaken");
		spell.put("School", "Transmutation");
		spell.put("Level","Drd 5");
		spell.put("Components", "V,S,DF,XP");
		spell.put("CastingTime", "24 hours");
		spell.put("Range", "Touch");
		spell.put("Target", "Animal or Tree touched");
		spell.put("Duration", "Instantaneous");
		spell.put("SavingThrow", "Will negates");
		spell.put("SpellResistance", "Yess");
		spell.put("Description", "You awaken a tree or animal to humanlike sentience. To succeed, you" +
				" must make a Will save (DC 10 + the animal’s current HD, or the HD the tree will have " +
				"once awakened). The awakened animal or tree is friendly toward you. You have no special" +
				" empathy or connection with a creature you awaken, although it serves you in specific tasks" +
				" or endeavors if you communicate your desires to it. An awakened tree has characteristics as" +
				" if it were an animated object (see the Monster Manual), except that it gains the plant type " +
				"and its Intelligence, Wisdom, and Charisma scores are each 3d6. An awakened plant gains" +
				" the ability to move its limbs, roots, vines, creepers, and so forth, and it has senses " +
				"similar to a human’s. An awakened animal gets 3d6 Intelligence, +1d3 Charisma, and +2 HD. " +
				"Its type becomes magical beast (augmented animal). An awakened animal can’t serve as an " +
				"animal companion, familiar, or special mount. An awakened tree or animal can speak one " +
				"language that you know, plus one additional language that you know per point of Intelligence" +
				" bonus (if any). XP Cost: 250 XP. ");
		spell.saveInBackground();
		
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Baleful Polymorph");
		spell.put("School", "Transmutation");
		spell.put("Level","Drd 5,Sor/Wiz 5");
		spell.put("Components", "V,S");
		spell.put("CastingTime", "1 standard action");
		spell.put("Range", "Close (25ft. + 5ft./2 levels");
		spell.put("Target", "One creature");
		spell.put("Duration", "Permanent");
		spell.put("SavingThrow", "Fortitude negates, Will partial; see text");
		spell.put("SpellResistance", "Yes");
		spell.put("Description", "As polymorph, except that you change the subject into a Small or smaller animal of no more than " +
				"1 HD (such as a dog, lizard, monkey, or toad). If the new form would prove fatal to the" +
				" creature (for example, if you polymorphed a landbound target into a fish, or a flying target" +
				" into a toad) the subject gets a +4 bonus on the save. If the spell succeeds, the subject" +
				" must also make a Will save. If this second save fails, the creature loses its extraordinary," +
				" supernatural, and spell-like abilities, loses its ability to cast spells (if it had the " +
				"ability), and gains the alignment, special abilities, and Intelligence, Wisdom, and Charisma " +
				"scores of its new form in place of its own. It still retains its class and level (or HD), as" +
				" well as all benefits deriving therefrom (such as base attack bonus, base save bonuses, and " +
				"hit points). It retains any class features (other than spellcasting) that aren’t " +
				"extraordinary, supernatural, or spell- like abilities. Incorporeal or gaseous creatures are " +
				"immune to being polymorphed, and a creature with the shapechanger subtype (such as a " +
				"lycanthrope or a doppelganger) can revert to its natural form as a standard action. ");
		spell.saveInBackground();
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Bane");
		spell.put("School", "Enchantment(Compulsion)[Fear,Mind-Affecting]");
		spell.put("Level","Clr 1");
		spell.put("Components", "V,S,DF");
		spell.put("CastingTime", "1 standard action");
		spell.put("Range", "50ft.");
		spell.put("Area","All enemies within 50ft.");
		spell.put("Duration", "1 min./level");
		spell.put("SavingThrow", "Will negates");
		spell.put("SpellResistance", "Yes");
		spell.put("Description", "Bane fills your enemies with fear and doubt. Each affected creature" +
				" takes a –1 penalty on attack rolls and a –1 penalty on saving throws against fear effects. " +
				"Bane counters and dispels bless.");
		spell.saveInBackground();
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Banishment");
		spell.put("School", "Abjuration");
		spell.put("Level","Clr 6, Sor/Wiz 7");
		spell.put("Components", "V,S,F");
		spell.put("CastingTime", "1 standard action");
		spell.put("Range", "Close (25ft. + 5ft./2 levels");
		spell.put("Targets", "One or more extraplanar creatures, no two of which can be more than 30ft. apart");
		spell.put("Duration", "Instantaneous");
		spell.put("SavingThrow", "Will negates");
		spell.put("SpellResistance", "Yes");
		spell.put("Description", "A banishment spell is a more powerful ver- sion of the dismissal spell. It " +
				"enables you to force extraplanar creatures out of your home plane. As many as 2 Hit Dice of" +
				" creatures per caster level can be banished. You can improve the spell’s chance of success " +
				"by presenting at least one object or substance that the target hates, fears, or otherwise " +
				"opposes. For each such object or substance, you gain a +1 bonus on your caster level check " +
				"to overcome the target’s spell resistance (if any), the saving throw DC increases by 2. For " +
				"example, if this spell were cast on a demon that hated light and was vulnerable to holy water " +
				"and cold iron weapons, you might use iron, holy water, and a torch in the spell. The three" +
				" items would give you a +3 bonus on your check to overcome the demon’s spell resistance and " +
				"add 6 to the spell’s save DC. At the DM’s option, certain rare items might work twice as well " +
				"as a normal item for the purpose of the bonuses (each providing a +2 bonus on the caster" +
				" level check against spell resistance and increasing the save DC by 4). Arcane Focus: Any " +
				"item that is distasteful to the subject (optional, see above). ");
		spell.saveInBackground();
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Barkskin");
		spell.put("School", "Transmutation");
		spell.put("Level","Drd 2, Rgr 2, Plant 2");
		spell.put("Components", "V,S,DF");
		spell.put("CastingTime", "1 standard action");
		spell.put("Range", "Touch");
		spell.put("Targets", "Living creature touched");
		spell.put("Duration", "10 min./level");
		spell.put("SavingThrow", "No");
		spell.put("SpellResistance", "Yes(harmless)");
		spell.put("Description", "Barkskin toughens a creature’s skin. The effect grants a +2 " +
				"enhancement bonus to the creature’s existing natural armor bonus. This enhancement" +
				" bonus increases by 1 for every three caster levels above 3rd, to a maximum of +5 at " +
				"caster level 12th. The enhancement bonus provided by barkskin stacks with the target’s" +
				" natural armor bonus, but not with other enhance- ment bonuses to natural armor. A creature" +
				" without natural armor has an effective natural armor bonus of +0, much as a character " +
				"wearing only normal clothing has an armor bonus of +0.");
		spell.saveInBackground();
		
		spell = new ParseObject("Spells");
		spell.put("Name", "Bear's Endurance");
		spell.put("School", "Transmutation");
		spell.put("Level","Clr 2, Drd 2, Rgr 2, Sor/Wiz 2");
		spell.put("Components", "V,S,DF");
		spell.put("CastingTime", "1 standard action");
		spell.put("Range", "Touch");
		spell.put("Targets", "Creatur touched");
		spell.put("Duration", "1 min./level");
		spell.put("SavingThrow", "Will negates(harmless)");
		spell.put("SpellResistance", "Yes");
		spell.put("Description", "The affected creature gains greater vitality and stamina. The spell " +
				"grants the subject a +4 enhancement bonus to Constitution, which adds the usual benefits " +
				"to hit points, Fortitude saves, Constitution checks, and so forth. Hit points gained by a" +
				" temporary increase in Constitution score are not temporary hit points. They go away when " +
				"the subject’s Constitution drops back to normal. They are not lost first as temporary hit " +
				"points are (see PH page 146). ");
		spell.saveInBackground();
		
	    //return the infalted view
	   return v;
	  }
	
	/**
	 * When the fragment resumes, update the page elements
	 */
	@Override
	public void onResume() {
		//Ensure that whenever you return to the basic tab the modifiers updates
		strMod.setText(String.valueOf(calcMod(getInt(strScore.getText().toString()))));
		dexMod.setText(String.valueOf(calcMod(getInt(dexScore.getText().toString()))));
		intMod.setText(String.valueOf(calcMod(getInt(intScore.getText().toString()))));
		conMod.setText(String.valueOf(calcMod(getInt(conScore.getText().toString()))));
		chaMod.setText(String.valueOf(calcMod(getInt(chaScore.getText().toString()))));
		wisMod.setText(String.valueOf(calcMod(getInt(wisScore.getText().toString()))));
		//Ensure temporary modifiers are updated
		strTmpMod.setText(String.valueOf(calcMod(getInt(strTmpScore.getText().toString()))));
		dexTmpMod.setText(String.valueOf(calcMod(getInt(dexTmpScore.getText().toString()))));
		intTmpMod.setText(String.valueOf(calcMod(getInt(intTmpScore.getText().toString()))));
		conTmpMod.setText(String.valueOf(calcMod(getInt(conTmpScore.getText().toString()))));
		chaTmpMod.setText(String.valueOf(calcMod(getInt(chaTmpScore.getText().toString()))));
		wisTmpMod.setText(String.valueOf(calcMod(getInt(wisTmpScore.getText().toString()))));
		
		super.onResume();
	}

	/*
	 * Set the element values based on the character object passed in
	 */
	public void setCharacter(Character ch)
	{
		c = ch;
		//Top half
		name.setText(c.getName());
		level.setText(String.valueOf(c.getLevel()));
		classs.setSelection(getSpinnerPosition(0, c.getClasss()));
		align.setSelection(getSpinnerPosition(1, c.getAlignment()));
		deity.setSelection(getSpinnerPosition(2, c.getDeity()));
		race.setSelection(getSpinnerPosition(3, c.getRace()));
		//Bottom half
		//Strength
		strScore.setText(String.valueOf(c.getStrength()));
		strTmpScore.setText(String.valueOf(c.getTmpStr()));
		//Dexterity
		dexScore.setText(String.valueOf(c.getDexterity()));
		dexTmpScore.setText(String.valueOf(c.getTmpDex()));
		//Constitution
		conScore.setText(String.valueOf(c.getConstitution()));
		conTmpScore.setText(String.valueOf(c.getTmpCon()));
		//Intelligence
		intScore.setText(String.valueOf(c.getIntelligence()));
		intTmpScore.setText(String.valueOf(c.getTmpInt()));
		//Charisma
		chaScore.setText(String.valueOf(c.getCharisma()));
		chaTmpScore.setText(String.valueOf(c.getTmpCha()));
		//Wisdom
		wisScore.setText(String.valueOf(c.getWisdom()));
		wisTmpScore.setText(String.valueOf(c.getTmpWis()));
		
	}
	
	/*
	 * Update the character passed in
	 */
	public Character updateCharacter(Character c)
	{
		//Update the values based on the content of the 
		c.setName(name.getText().toString());
		c.setLevel(getInt(level.getText().toString()));
		c.setClasss(classs.getSelectedItem().toString());
		c.setAlignment(align.getSelectedItem().toString());
		c.setDeity(deity.getSelectedItem().toString());
		c.setRace(race.getSelectedItem().toString());
		c.setStrength(getInt(strScore.getText().toString()));
		c.setTmpStr(getInt(strTmpScore.getText().toString()));
		c.setDexterity(getInt(dexScore.getText().toString()));
		c.setTmpDex(getInt(dexTmpScore.getText().toString()));
		c.setConstitution(getInt(conScore.getText().toString()));
		c.setTmpCon(getInt(conTmpScore.getText().toString()));
		c.setIntelligence(getInt(intScore.getText().toString()));
		c.setTmpInt(getInt(intTmpScore.getText().toString()));
		c.setWisdom(getInt(wisScore.getText().toString()));
		c.setTmpWis(getInt(wisTmpScore.getText().toString()));
		c.setCharisma(getInt(chaScore.getText().toString()));
		c.setTmpCha(getInt(chaTmpScore.getText().toString()));
		
		
		//Return the populated character
		return c;
	}
	
	/*
	 * Return the int value of a string.  if the string is blank return 0
	 */
	public int getInt(String s)
	{
		int r =0;
		if (s.length()>0)
		{
			r=Integer.parseInt(s);
		}
		return r;
	}
	
	/*
	 * The position you want the spinner to be set to
	 */
	public int getSpinnerPosition(int b, //the class you are switching
			String s)
	{
		//The value to return
		int r=0;
		//The array of values to compare to
		String ar[]=null;
		
		switch (b)
		{
		case 0:	//Classes
			ar=CLASSES;
			break;
		case 1:	//Alignment
			ar=ALIGNMENT;
			break;
		case 2:	//Deities
			ar=DEITIES;
			break;
		case 3:	//Races
			ar=RACES;
			break;
		}
		//compare the String passed in to the chosen array
		for (int i=0; i<ar.length;i++)
		{
			if (s.equals(ar[i]))
			{
				r=i;
			}
		}
		//Return the position
		return r;
	}
	
	/*
	 * Calculate the modifier based off of the score passed in
	 */
	public int calcMod(int score)
	{
		//formula: (score-10)/2
		return (score-SUBMOD)/HALF;
	}
	
	/*
	 * Update the Stats Textviews when view is lost
	 */
	public class StatsListener implements EditText.OnFocusChangeListener
	{

		@Override
		public void onFocusChange(View v, boolean hasFocus) {
			if(!hasFocus)
			{
				onResume();
			}
		}
	}
	
	public class LevelListener implements EditText.OnFocusChangeListener
	{

		@Override
		public void onFocusChange(View v, boolean hasFocus) {
			if (!hasFocus)
			{
				if((!(c.gettHealth()==0)) && (!(c.getLevel()==Integer.parseInt(level.getText().toString()))))
				{
					//determine the difference between the previous level and the new level
					int difference = Integer.parseInt(level.getText().toString())-c.getLevel();
					
					if(difference>0)
					{//level up
						for(int i=0; i<difference;i++)
						{
							//Add 2 because for correct health calculation the value must be greater than 1
							c.settHealth(c.gettHealth()+c.calcCurrentLevelHealth(i+2));
						}
					}else if(difference<0)
					{//level down
						difference = difference*-1;
						for(int i=0;i<difference;i++)
						{
							//Add 2 because for correct health calculation the value must be greater than 1
							c.settHealth(c.gettHealth()-c.calcCurrentLevelHealth(i+2));
						}
					}
					//Set the current health to the total health
					c.setcHealth(c.gettHealth());
				}
			}
		}
	}
	
	public class SelectedListener implements OnItemSelectedListener
	{
		@Override
		public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2,
				long arg3) {
			
			//When a class is selcted query Parse to get character details
			String classSelected = classs.getSelectedItem().toString();
			//ensure that the spinner label was not selected
			if (!(classSelected.equalsIgnoreCase(CLASSES[0])))
			{
				//Get the class details for the given class
				new ParseQuery("ClassDetails").whereEqualTo("Name", classSelected).getFirstInBackground(new GetCallback() {
					
					@Override
					public void done(ParseObject classDetails, ParseException e) {
						if (e==null)
						{
							int p = c.getLevel()-1; //The position in the array associated with the current level
							//the array is base 0 but the level is not
							
							//Set the base attack of the character to the returned value
							c.setBaseAttack((Integer)classDetails.getList("BaseAttackBonus").get(p));
							
							//set the hitdie
							c.setHitDie(classDetails.getInt("hitDie"));
							
							//Set the characters saves
							c.setWill(c.calcSave(Integer.parseInt(classDetails.getList("WillSave").get(p).toString()),c.getModWis(),0));
							c.setReflex(c.calcSave(Integer.parseInt(classDetails.getList("RefSave").get(p).toString()),c.getModDex(), 0));
							c.setFortitude(c.calcSave(Integer.parseInt(classDetails.getList("FortSave").get(p).toString()),c.getModCon(), 0));
						}
					}
				});
				
				//if the class has changed reset the health
				if (!(classSelected.equalsIgnoreCase(c.getClasss())))
				{
					//set the health
					c.settHealth(0);
					c.setcHealth(0);
				}
			}
		}

		@Override
		public void onNothingSelected(AdapterView<?> arg0) {
						
		}
		
	}
	

}
